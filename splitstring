#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_WORDS 64
#define MAX_WORD_LENGTH 128

// Function to split a string into words (ignores repeat delimiters)
char **strtow(const char *str, const char *delimiters) {
    char **words = malloc((MAX_WORDS + 1) * sizeof(char *));
    if (words == NULL) {
        perror("strtow: malloc failed");
        exit(EXIT_FAILURE);
    }

    int word_count = 0;
    const char *ptr = str;

    while (*ptr != '\0' && word_count < MAX_WORDS) {
        // Skip leading delimiters
        while (*ptr != '\0' && strchr(delimiters, *ptr) != NULL) {
            ptr++;
        }

        if (*ptr == '\0') {
            break;  // Reached the end of the string
        }

        const char *word_start = ptr;
        while (*ptr != '\0' && strchr(delimiters, *ptr) == NULL) {
            ptr++;
        }

        int word_length = ptr - word_start;
        char *word = malloc((word_length + 1) * sizeof(char));
        if (word == NULL) {
            perror("strtow: malloc failed");
            exit(EXIT_FAILURE);
        }

        strncpy(word, word_start, word_length);
        word[word_length] = '\0';

        words[word_count] = word;
        word_count++;
    }

    words[word_count] = NULL;

    return words;
}

// Function to split a string into words
char **strtow2(const char *str, const char *delimiters) {
    char **words = malloc((MAX_WORDS + 1) * sizeof(char *));
    if (words == NULL) {
        perror("strtow2: malloc failed");
        exit(EXIT_FAILURE);
    }

    int word_count = 0;
    const char *ptr = str;
    char *word = malloc(MAX_WORD_LENGTH * sizeof(char));
    if (word == NULL) {
        perror("strtow2: malloc failed");
        exit(EXIT_FAILURE);
    }

    while (*ptr != '\0' && word_count < MAX_WORDS) {
        if (strchr(delimiters, *ptr) == NULL) {
            *word = *ptr;
            word++;
        } else {
            if (word != NULL && word != words[word_count - 1]) {
                *word = '\0';
                words[word_count] = word - (strlen(word) - 1);
                word_count++;
            }
        }
        ptr++;
    }

    if (word != NULL && word != words[word_count - 1]) {
        *word = '\0';
        words[word_count] = word - (strlen(word) - 1);
        word_count++;
    }

    words[word_count] = NULL;

    return words;
}

// Function to test if the current character in the buffer is a chain delimiter
bool is_chain(const char *buffer, int index) {
    char current_char = buffer[index];

    // Check if the current character is a chain delimiter
    if (current_char == '&' || current_char == '|') {
        // Check if the next character is the same as the current character
        if (buffer[index + 1] == current_char) {
            return true;  // It is a chain delimiter
        }
    }

    return false;
}

// Function to check if we should continue chaining based on the last status
bool check_chain(bool last_status, const char *chain_operator) {
    if (strcmp(chain_operator, "&&") == 0) {
        return last_status;  // Continue chaining if the last status is true
    } else if (strcmp(chain_operator, "||") == 0) {
        return !last_status;  // Continue chaining if the last status is false
    }

    return true;  // Default: continue chaining
}

// Function to replace aliases in the tokenized string
void replace_alias(char **tokens) {
    // Implementation of alias replacement goes here
    // Iterate through the tokens and replace aliases if found
}

// Function to replace variables in the tokenized string
void replace_vars(char **tokens) {
    // Implementation of variable replacement goes here
    // Iterate through the tokens and replace variables if found
}

// Function to replace a string with another string in the tokenized string
void replace_string(char **tokens, const char *search, const char *replace) {
    // Implementation of string replacement goes here
    // Iterate through the tokens and replace strings if found
}

int main() {
    // Test the implemented functions here

    return 0;
}
